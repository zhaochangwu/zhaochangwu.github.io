<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="这是一个程序猿的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="这是一个程序猿的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="这是一个程序猿的博客">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>这是一个程序猿的博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">这是一个程序猿的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">路漫漫其修远兮，吾将上下而求索。</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/31/简历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵昌吾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="这是一个程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/31/简历/" itemprop="url">
                  简历
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-31 22:27:56 / 修改时间：16:39:44" itemprop="dateCreated datePublished" datetime="2018-07-31T22:27:56+08:00">2018-07-31</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><table>
<thead>
<tr>
<th>姓名</th>
<th>赵昌吾</th>
</tr>
</thead>
<tbody>
<tr>
<td>邮箱</td>
<td><a href="mailto:changwuzhao@foxmail.com" target="_blank" rel="noopener">changwuzhao@foxmail.com</a></td>
</tr>
<tr>
<td>性别</td>
<td>男</td>
</tr>
<tr>
<td>电话</td>
<td>15190608776</td>
</tr>
<tr>
<td>生日</td>
<td>1993年7月</td>
</tr>
<tr>
<td>居住地</td>
<td>南京</td>
</tr>
</tbody>
</table>
<h1 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h1><p>2011年9月—2015年07月   山西大学 电子信息科学与技术 本科</p>
<h1 id="技能描述"><a href="#技能描述" class="headerlink" title="技能描述"></a>技能描述</h1><ol>
<li>熟练使用Xcode开发iPhone和iPad应用，熟悉oc、swift</li>
<li>熟悉iOS 常用第三方</li>
<li>熟练使用 Git 进行版本管理</li>
<li>熟悉 CocoPods 和 Carthage</li>
<li>熟练使用 Cordova 框架实现和 H5页面的交互</li>
<li>掌握 GCD 的基本使用</li>
<li>熟悉测试框架 Robot framework 和 appium</li>
<li>能够使用 Gitlab 搭建自动化部署打包的环境</li>
<li>了解 Html, css, js, ReactJs</li>
<li>了解python</li>
</ol>
<h1 id="工作经验"><a href="#工作经验" class="headerlink" title="工作经验"></a>工作经验</h1><table>
<thead>
<tr>
<th>时间</th>
<th>工作地点</th>
<th>工作内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>2018/1-至今</td>
<td>瞬联软件科技（北京）有限公司</td>
<td></td>
</tr>
<tr>
<td>2016/7—2017/12</td>
<td>华泰证券</td>
<td>iOS 开发</td>
</tr>
<tr>
<td>2015/6—2016/7</td>
<td>瞬联软件科技（北京）有限公司</td>
<td>iOS 开发</td>
</tr>
<tr>
<td>2014/10－2015/5</td>
<td>软件外包</td>
<td>iOS 开发</td>
</tr>
</tbody>
</table>
<h1 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h1><h2 id="Nuance-SDK"><a href="#Nuance-SDK" class="headerlink" title="Nuance SDK"></a>Nuance SDK</h2><p><em>2018/6-至今</em><br><strong>责任描述</strong></p>
<ol>
<li>开发文件上传, link preview 功能</li>
<li>修改bug</li>
<li>使用carthage优化第三方库的管理方式</li>
<li>使用appium去编写UI自动化测试</li>
</ol>
<p><strong>项目描述</strong><br>聊天sdk</p>
<h2 id="GM车载系统自动化测试"><a href="#GM车载系统自动化测试" class="headerlink" title="GM车载系统自动化测试"></a>GM车载系统自动化测试</h2><p><em>2018/1-2018/</em></p>
<p><strong>责任描述</strong></p>
<ol>
<li>修复bug</li>
<li>添加文字识别功能</li>
<li>添加部分图标识别的功能</li>
<li>适配iOS10，11</li>
</ol>
<p><strong>项目描述</strong></p>
<p>python实现的工具，用来辅助自动化测试。使用了OpenCV，控制视频的开始和结束，页面元素的检测等。<br>swift 实现的控制手机蓝牙的工具。</p>
<h2 id="华泰移动理财工作平台"><a href="#华泰移动理财工作平台" class="headerlink" title="华泰移动理财工作平台"></a>华泰移动理财工作平台</h2><p><em>2016/07-2017/12</em></p>
<p><strong>责任描述</strong></p>
<ol>
<li>独立完成项目需求。实现原生页面和网页之间的来回切换交互；组件化；</li>
<li>消息推送；列表展示筛选；</li>
<li>使用 Robot framework 框架编写接口自动化测试；</li>
<li>编写文档；搭建持续集成环境；</li>
<li>参与需求和测试用例评审，根据平台特性提出意见。</li>
</ol>
<p><strong>项目描述</strong></p>
<p>给客户经理使用，实现任务下发，任务处理，产品管理，客户管理，绩效查看等功能。<br>推送每日任务。<br>后来根据用户反馈，优化需求，重构了一次</p>
<h2 id="一款打车软件"><a href="#一款打车软件" class="headerlink" title="一款打车软件"></a>一款打车软件</h2><p><em>2016/02-2016/7 和 2015/07 - 2015/10</em></p>
<p><strong>责任描述</strong></p>
<ol>
<li>开发行程发布界面，地址收藏，历史行程，好友，黑名单；</li>
<li>网络接口的封装调试；</li>
<li>应用弹窗的定制；</li>
</ol>
<p><strong>项目描述</strong></p>
<p>司机和乘客发布行程，系统进行匹配。给用户推送行程匹配结果和行程状态。<br>行程路线会在地图上显示，行程开始后，地图上线实时位置和实际行驶路线。<br>用户可以收藏常用地点。用户可以添加好友或者拉黑。<br>乘车费用通过积分结算，可以查看历史行程及相应的积分状况。</p>
<h2 id="一个公司管理系统"><a href="#一个公司管理系统" class="headerlink" title="一个公司管理系统"></a>一个公司管理系统</h2><p><em>2015/10 - 2016/2</em></p>
<p><strong>责任描述</strong></p>
<ol>
<li>部分UI的绘制：列表，封装下拉菜单，筛选列表的信息</li>
<li>封装部分网络接口的封装</li>
<li>部分数据本地化</li>
</ol>
<p><strong>项目描述</strong></p>
<p>一个公司管理系统，管理公司的请假，出差等的审批签核，仓库的货物流通记录。消息展示及推送。</p>
<h2 id="Nexturn"><a href="#Nexturn" class="headerlink" title="Nexturn"></a>Nexturn</h2><p><em>2015/6 - 2016/7</em></p>
<p><strong>责任描述</strong><br>app维护, 添加新功能，修改bug</p>
<p><strong>项目描述</strong></p>
<p>一个控制智能家居的app，通过app可以控制如电灯等设备。<br>实现定时任务，定时控制设备的开关，并推送状态给应用。<br>获取智能设备状态，推送状态更新。</p>
<h2 id="逛建材-demo"><a href="#逛建材-demo" class="headerlink" title="逛建材(demo)"></a>逛建材(demo)</h2><p><em>2015.01 - 2015.04</em></p>
<p><strong>责任描述</strong></p>
<ol>
<li>项目框架搭建</li>
<li>UI界面的绘制</li>
<li>设计数据模型</li>
<li>解析后台数据</li>
</ol>
<p><strong>项目描述</strong></p>
<p>一款以手机为展示端，聚焦家装建材行业O2O模式的电商平台；<br>装修业主足不出户就能浏览各种产品的销售信息及商家的促销信息。<br>装修用户可以随时通过手机注册下订单，并且支持定金随时退</p>
<h1 id="语言能力"><a href="#语言能力" class="headerlink" title="语言能力"></a>语言能力</h1><p>英语：英语四级</p>
<h1 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h1><ol>
<li>很稳定</li>
<li>自信、友好、乐于沟通；</li>
<li>表达能力正常，能够正确描述自己的需求、问题</li>
<li>踏实诚恳，工作认真，具有很强的责任心，能够认真负责的完成自己的任务！</li>
<li>有较强的组织协调能力，保证工作及时高效的完成</li>
<li>能够承担较大工作压力，吃苦耐劳。</li>
<li>热爱编程，且有较强的学习适应能力，能够通过自学掌握新知识</li>
<li>能够根据客户需求提出自己的开发建议</li>
<li>还经常逛技术论坛，关注技术牛人博客。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/robotframework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵昌吾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="这是一个程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/15/robotframework/" itemprop="url">
                  Robot Framework 安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-15 16:27:13" itemprop="dateCreated datePublished" datetime="2017-09-15T16:27:13+08:00">2017-09-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-31 10:46:41" itemprop="dateModified" datetime="2018-07-31T10:46:41+08:00">2018-07-31</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/robotframework/" itemprop="url" rel="index"><span itemprop="name">robotframework</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Robot-Framework"><a href="#Robot-Framework" class="headerlink" title="Robot Framework"></a>Robot Framework</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><a href="http://robotframework.org/" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://github.com/robotframework" target="_blank" rel="noopener">github</a></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="基础环境安装"><a href="#基础环境安装" class="headerlink" title="基础环境安装"></a>基础环境安装</h3><ul>
<li>首先需要python2的环境</li>
<li>使用<code>pip</code>去安装时官方的推荐方式，如果使用的时<code>python2.7</code>的版本，应该自带了<code>pip</code>，如果没有<code>pip</code>，自行百度<h3 id="robot-framework-安装"><a href="#robot-framework-安装" class="headerlink" title="robot framework 安装"></a>robot framework 安装</h3><h4 id="通过工具安装"><a href="#通过工具安装" class="headerlink" title="通过工具安装"></a>通过工具安装</h4></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装robot framework</span></span><br><span class="line">pip install robotframework</span><br><span class="line"><span class="comment"># 安装依赖库</span></span><br><span class="line">pip install -U requests</span><br><span class="line">pip install -U robotframework-requests</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有一些安装工具也可以用，<code>easy_install</code>等等啊，各位看官自己搞定啊，我就会这一个</p>
</blockquote>
<h4 id="从源码安装"><a href="#从源码安装" class="headerlink" title="从源码安装"></a>从源码安装</h4><p>鉴于公司的网络问题，说一下怎么从源码安装<br>1 先将源码下载并解压<br>2 进入到解压出文件夹内, 确认目录下存在<code>setup.py</code><br>3 运行安装命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>ps: 因为网络问题肯能存在运行命令的时候安装的依赖库下载不下来的问题，所以推荐可以先将依赖库安装了</p>
</blockquote>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>以下两种方式效果相同<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">robot --<span class="built_in">help</span></span><br><span class="line">python -m robot --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></p>
<h3 id="RIDE-安装"><a href="#RIDE-安装" class="headerlink" title="RIDE 安装"></a>RIDE 安装</h3><p><a href="https://github.com/robotframework/RIDE/wiki" target="_blank" rel="noopener"><code>RIDE</code></a>是wxpython开发的图形界面，可以方便我们写case, 个人觉得不是很用，同样功能的工具还有，RED(eclipes-java的扩展)，atom、sublime插件等，详细自己查阅<a href="http://robotframework.org/#tools" target="_blank" rel="noopener">官网</a></p>
<p>这个工具不太推荐 mac 使用，因为依赖<code>wxpython2.8.12.1</code>，需要32bit的环境，<code>mac</code>装起来比较麻烦</p>
<p><code>win</code>的话，可以直接使用<code>*.exe</code>安装, <a href="https://sourceforge.net/projects/wxpython/files/wxPython/2.8.12.1/" target="_blank" rel="noopener">下载地址</a>, 我们需要的是<code>win32 unicoding</code>版本。</p>
<p><code>wxPython</code>安装好了的话，剩下的就不麻烦了，直接通过源码安装或者使用<code>pip</code>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install robotframework-ride</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">python ride.py</span><br></pre></td></tr></table></figure></p>
<h2 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h2><ul>
<li><a href="https://github.com/requests/requests/" target="_blank" rel="noopener">requests</a></li>
<li><a href="https://github.com/bulkan/robotframework-requests" target="_blank" rel="noopener">robotframework-requests</a></li>
<li><a href="https://github.com/robotframework/Selenium2Library" target="_blank" rel="noopener">Selenium2Library</a></li>
<li><a href="https://github.com/franz-see/Robotframework-Database-Library" target="_blank" rel="noopener">DatabaseLibrary</a></li>
</ul>
<h2 id="其他问题解决"><a href="#其他问题解决" class="headerlink" title="其他问题解决"></a>其他问题解决</h2><ul>
<li><a href="自行百度吧">日志打印的中文编码问题</a></li>
</ul>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>这次公司有需求让我做一个 demo，最终环境需要我配置到一台 linux 服务器上</p>
<h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>1 给我分配的用户没有权限，无法系统内置的 python 目录下的写入权限，所以无法直接通过 <code>python setup.py install</code>，<code>sudo</code> 也不行<br>2 公司对网络有限制，及时可以使用 <code>python setup.py install</code>， 相关的依赖库也会安装失败</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在自己的用户目录下面安装了一个新的 <code>python</code>, 使之与系统的 <code>python</code> 共存又独立<br><a href="https://github.com/csuldw/EasyNotes/blob/master/chapter2_1-environment.md" target="_blank" rel="noopener">参考</a></p>
<p>1 先去下载 <code>python</code> 版本库 <a href="https://www.python.org/ftp/python/" target="_blank" rel="noopener">https://www.python.org/ftp/python/</a><br>2 解压<code>tar -xzf</code>，<code>cd</code> 进去<br>3 在你想要安装的路径下建文目录, <code>mkdir -p ~/python27</code><br>4 <code>./configure --prefix=&quot;~/python27&quot;</code><br>5 <code>make</code><br>6 <code>make install</code>, 等待安装完了其实就可以用了, <code>~/python27/bin/python setup.py install</code><br>7 设置别名，alias mypython=’~/python27/bin/python’，<code>mypython setup.py install</code><br>8 后面你需要手动安装 python 库的时候就使用 <code>mypython</code>,  比方说<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行 ride</span></span><br><span class="line">$ mypython ride.py</span><br><span class="line"><span class="comment"># 运行 robot 命令</span></span><br><span class="line">$ mypython -m robot --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/19/初识 CGD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵昌吾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="这是一个程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/19/初识 CGD/" itemprop="url">
                  初识 GCD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-19 15:32:33" itemprop="dateCreated datePublished" datetime="2017-07-19T15:32:33+08:00">2017-07-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-31 10:46:41" itemprop="dateModified" datetime="2018-07-31T10:46:41+08:00">2018-07-31</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="初识-GCD"><a href="#初识-GCD" class="headerlink" title="初识 GCD"></a>初识 GCD</h1><h2 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h2><p>Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>
<p>除了代码的平行执行能力，GCD还提供高度集成的事件控制系统。可以设置句柄来响应文件描述符、mach ports（Mach port 用于 OS X上的进程间通讯）、进程、计时器、信号、用户生成事件。这些句柄通过GCD来并发执行。</p>
<p>GCD的API很大程度上基于block，当然，GCD也可以脱离block来使用，比如使用传统c机制提供函数指针和上下文指针。实践证明，当配合block使用时，GCD非常简单易用且能发挥其最大能力。<br>你可以在Mac上敲命令“man dispatch”来获取GCD的文档。</p>
<h2 id="Dispatch-Objects"><a href="#Dispatch-Objects" class="headerlink" title="Dispatch Objects"></a>Dispatch Objects</h2><p>尽管GCD是纯c语言的，但它被组建成面向对象的风格，GCD对象被称为dispatch object。Dispatch object像Cocoa对象一样是引用计数的。使用dispatch_release和dispatch_retain函数来操作dispatch object的引用计数来进行内存管理</p>
<h2 id="Dispatch-Queues"><a href="#Dispatch-Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>GCD的基本概念就是dispatch queue。dispatch queue是一个对象，它可以接受任务，并将任务以先到先执行的顺序来执行。dispatch queue可以是并发的或串行的。并发任务会像NSOperationQueue那样基于系统负载来合适地并发进行，串行队列同一时间只执行单一任务。</p>
<h3 id="GCD中有三种队列类型："><a href="#GCD中有三种队列类型：" class="headerlink" title="GCD中有三种队列类型："></a>GCD中有三种队列类型：</h3><h4 id="1-The-main-queue"><a href="#1-The-main-queue" class="headerlink" title="1 The main queue:"></a>1 The main queue:</h4><p>与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></p>
<h4 id="2-Global-queues"><a href="#2-Global-queues" class="headerlink" title="2 Global queues:"></a>2 Global queues:</h4><p>全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。可以调用dispatch_get_global_queue函数传入优先级来访问队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW,0);</span><br></pre></td></tr></table></figure>
<h4 id="3-用户创建的队列"><a href="#3-用户创建的队列" class="headerlink" title="3 用户创建的队列:"></a>3 用户创建的队列:</h4><p>没有一个特定的名字来形容这种队列，这些的队列是用函数 dispatch_queue_create 创建的队列.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.apple.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>第一个参数是标签，Apple建议我们使用倒置域名来命名队列，比如“com.dreamingwish.subsystem.task”。这些名字会在崩溃日志中被显示出来，也可以被调试器调用，这在调试中会很有用。</p>
</blockquote>
<ul>
<li>Concurrent：<br>1 用来执行大量的并行任务，GCD自动创建了四种全局的Concurrent队列，他们只是优先级不同：<br>2 因为这队列是全局的，不需要retain和release，掉用也会被忽略<br>3 还可以创建自己的并行队列</li>
<li>Serial：<br>1 串行队列会确保每个任务按顺序执行<br>2 尽量使用并行队列，而不是去创建多个串行队列</li>
</ul>
<h3 id="dispatch-queue-API"><a href="#dispatch-queue-API" class="headerlink" title="dispatch queue API"></a>dispatch queue API</h3><h4 id="dispatch-async（非同步）"><a href="#dispatch-async（非同步）" class="headerlink" title="dispatch_async（非同步）"></a>dispatch_async（非同步）</h4><p>block提交到queue之后会继续执行队列后面的任务不会等待<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block int a = 15;</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">  sleep(2);</span><br><span class="line">  a++;</span><br><span class="line">  NSLog(@&quot;block %i&quot;, a);</span><br><span class="line">&#125;);</span><br><span class="line">sleep(2);</span><br><span class="line">NSLog(@&quot;%i&quot;, a);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>常见的网络请求数据多线程执行模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">　　//子线程中开始网络请求数据</span><br><span class="line">　　//更新数据模型</span><br><span class="line">　　dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">　//在主线程中更新UI代码</span><br><span class="line">　&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="dispatch-sync（同步）"><a href="#dispatch-sync（同步）" class="headerlink" title="dispatch_sync（同步）"></a>dispatch_sync（同步）</h4><p>block提交到队列之后，会先将block执行完，再继续执行queue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block int a = 15;</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">  sleep(2);</span><br><span class="line">  a++;</span><br><span class="line">  NSLog(@&quot;block %i&quot;, a);</span><br><span class="line">&#125;);</span><br><span class="line">sleep(2);</span><br><span class="line">NSLog(@&quot;%i&quot;, a);</span><br></pre></td></tr></table></figure></p>
<h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><p>延迟执行block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block int a = 20;</span><br><span class="line">NSLog(@&quot;%i&quot;, a);</span><br><span class="line">//需要用下面的方法初始化 dispatch_time 否则无效</span><br><span class="line">dispatch_time_t delay = dispatch_time(DISPATCH_TIME_NOW, 2*NSEC_PER_SEC);</span><br><span class="line">  dispatch_after(delay, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    a++;</span><br><span class="line">    NSLog(@&quot;block %i&quot;, a);</span><br><span class="line">  &#125;);</span><br><span class="line">NSLog(@&quot;%i&quot;, a);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>block的执行时间由参数 dispatch_time_t when 来确定，与串行队列和并行队列无关，但是内部的执行顺序仍然由队列的类型决定</p>
</blockquote>
<h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h4><p>重复执行block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t newQueue = dispatch_queue_create(&quot;com.dispatch.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_apply(10, newQueue, ^(size_t time) &#123;</span><br><span class="line">  NSLog(@&quot;c %zu&quot;, time);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h4><ul>
<li>它会把需要执行的任务对象指定到不同的队列中去处理，这个任务对象可以是dispatch队列，</li>
<li>也可以是dispatch源。而且这个过程可以是动态的，可以实现队列的动态调度管理等等。</li>
<li>比如说有两个队列dispatchA和dispatchB，这时把dispatchA指派到dispatchB：</li>
</ul>
<h2 id="Dispatch-Groups？？使用组的意义"><a href="#Dispatch-Groups？？使用组的意义" class="headerlink" title="Dispatch Groups？？使用组的意义"></a>Dispatch Groups？？使用组的意义</h2><h3 id="dispatch-group-create"><a href="#dispatch-group-create" class="headerlink" title="dispatch_group_create"></a>dispatch_group_create</h3><p>创建组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(dispatch_group_create(), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;block&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;---&quot;);</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h3><p>所有block执行完了 在执行notify的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();//创建一个group</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">  NSLog(@&quot;block&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">  NSLog(@&quot;block&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;//所有的block执行完毕之后调用该block</span><br><span class="line">  NSLog(@&quot;notif&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">  NSLog(@&quot;block&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatch-group-wait"><a href="#dispatch-group-wait" class="headerlink" title="dispatch_group_wait"></a>dispatch_group_wait</h3><p>延迟执行block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">  NSLog(@&quot;block&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_time_t timeOut = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);</span><br><span class="line">NSLog(@&quot;%ld&quot;, dispatch_group_wait(group, timeOut));</span><br></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Barrier"><a href="#Dispatch-Barrier" class="headerlink" title="Dispatch Barrier"></a>Dispatch Barrier</h2><p>barrier 能够在一个并行的派遣队列中创建一个串行的点。当遇到一个barrier 时，并行队列会先执行完所有在barrier 之前就已经提交的block 然后再执行barrier 的block 然后，执行完成之后，队列重新唤起正常的执行行为</p>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><p>会直接在 唤起 执行barrier 之后继续执行后面的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">  NSLog(@&quot;barrier&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatch-barrier-sync"><a href="#dispatch-barrier-sync" class="headerlink" title="dispatch_barrier_sync"></a>dispatch_barrier_sync</h3><p>会在执行完 barrier 的block 之后才继续执行 后面的 block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync(queue, ^&#123;</span><br><span class="line">  NSLog(@&quot;barrier&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>和dispatch_async || dispatch_sync区别??</p>
</blockquote>
<h2 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><h3 id="一般使用流程"><a href="#一般使用流程" class="headerlink" title="一般使用流程"></a>一般使用流程</h3><ul>
<li>1 创建diapatch_source_t 对象</li>
<li>2 添加事件</li>
<li>3 因为现在的source是repend的 需要resume<h3 id="DISPATCH-SOURCE-TYPE-TIMER"><a href="#DISPATCH-SOURCE-TYPE-TIMER" class="headerlink" title="DISPATCH_SOURCE_TYPE_TIMER"></a>DISPATCH_SOURCE_TYPE_TIMER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.timerSource =  dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(self.timerSource, dispatch_time(DISPATCH_TIME_NOW, 0), 1 * NSEC_PER_SEC,  0*NSEC_PER_SEC);</span><br><span class="line">dispatch_source_set_event_handler(self.timerSource, ^&#123;</span><br><span class="line">  NSLog(@&quot;timer block&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(self.timerSource);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>定时器必须是全局的，如果是局部变量的话不会起作用</p>
</blockquote>
<h3 id="DISPATCH-SOURCE-TYPE-DATA-ADD"><a href="#DISPATCH-SOURCE-TYPE-DATA-ADD" class="headerlink" title="DISPATCH_SOURCE_TYPE_DATA_ADD"></a>DISPATCH_SOURCE_TYPE_DATA_ADD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t  source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">  NSLog(@&quot;source data %lu&quot;,dispatch_source_get_data(source));</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_queue_t queue =    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_apply(5, queue, ^(size_t index) &#123;</span><br><span class="line">  long datum = random()%100;</span><br><span class="line">  NSLog(@&quot;add data %ld&quot;, datum);</span><br><span class="line">  dispatch_source_merge_data(source, datum);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(source);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/10/使用oh my zsh配置终端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵昌吾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="这是一个程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/10/使用oh my zsh配置终端/" itemprop="url">
                  使用「oh my zsh」配置MAC终端
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-07-10 16:27:13" itemprop="dateCreated datePublished" datetime="2016-07-10T16:27:13+08:00">2016-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-31 10:46:41" itemprop="dateModified" datetime="2018-07-31T10:46:41+08:00">2018-07-31</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MAC/" itemprop="url" rel="index"><span itemprop="name">MAC</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用「oh-my-zsh」配置MAC终端"><a href="#使用「oh-my-zsh」配置MAC终端" class="headerlink" title="使用「oh my zsh」配置MAC终端"></a>使用「oh my zsh」配置MAC终端</h1><p>首先什么是oh-my-zsh, 说实话, 我也不是特别明白, 我过我看同事的MAC终端都用这个配置了, 我就回来学习配置了一下.</p>
<p><img src="/images/OhMyZsh/OhMyZsh.png" alt="ohmyzsh"></p>
<p>最初我的目的很单纯. 只是为了我的mac有个好看的主题(大家请不要嘲笑我). 结果学习下发现, 除了主题S, 这个东西还有很多牛逼的功能(不管你怎么认为, 反正我觉得很牛逼).</p>
<h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>好了, 废话有点多, 下面简单介绍下「oh my zsh」能干啥</p>
<ul>
<li>更换终端主题</li>
<li>给一些终端命令设置别名</li>
<li>提供了丰富的插件, 具体插件的功能需要大家自行研究</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p>自动安装很简单, 只要在终端中执行下面两个命令中的任意一句就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure>
<h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><ol>
<li><p>首先使用下面的命令, 从<code>github</code>将代码先clone下来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br></pre></td></tr></table></figure>
</li>
<li><p>这一步是可选的, 备份你存在的<code>~/.zshrc</code>文件. 这个文件是配置主题, 插件, 和命令别名的文件, 还有其他一些设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/.zshrc ~/.zshrc.orig</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个新的<code>~/.zshrc</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>将默认的<code>shell</code>切换过来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成上面的步骤之后, 重启终端就可以看到效果了</p>
</li>
</ol>
<p>我是用的自动安装, 手动安装有什么的问题的话自行解决啊:grimacing:</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装完成后就是根据自己的喜好进行配置, 下面说的配置都是修改<code>~/.zshrc</code>文件来完成的, 关于<strong>自定义主题插件</strong>等如何使用这里先<strong>不</strong>做介绍</p>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><ul>
<li>找到<code>ZSH_THEME</code>(我的是在第8行), 默认的是<code>ZSH_THEME=&quot;robbyrussell&quot;</code>, 只要把引号里换成你自己喜欢的主题就好了</li>
<li>如果你不想任何主题生效, 只要写成<code>ZSH_THEME=&quot;&quot;</code>就行了</li>
<li>主题可以在<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/themes" target="_blank" rel="noopener">GitHub上的themes文件夹</a>看到</li>
<li>也可以在本地的<code>~/.oh-my-zsh/themes</code>文件夹中看到</li>
</ul>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul>
<li>找到<code>ZSH_THEME</code>(我的是在第52行), <code>plugins=()</code>在括号中填写你需要的插件就可以了.</li>
<li>有多个插件可以用<code>plugins=(rails git textmate ruby lighthouse)</code>的形式</li>
<li>插件可以在<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins" target="_blank" rel="noopener">GitHub上的plugins文件夹</a>看到</li>
<li>也可以在本地的<code>~/.oh-my-zsh/plugins</code>文件夹中看到</li>
<li>这里有官方给出的<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview" target="_blank" rel="noopener">插件简介</a></li>
</ul>
<blockquote>
<p>提示: 加太多的插件是会变慢的</p>
</blockquote>
<h4 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias zshconfig=&quot;mate ~/.zshrc&quot;</span><br><span class="line">alias ohmyzsh=&quot;mate ~/.oh-my-zsh&quot;</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>还有很多其他的功能和配置, 大家自行查找:grimacing:</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>这篇博客介绍了什么是Zsh, 以及「oh my zsh」的使用配置<br><a href="https://zhuanlan.zhihu.com/p/19556676" target="_blank" rel="noopener">终极 Shell——ZSH</a></li>
<li>「oh my zsh」的 <a href="http://ohmyz.sh/" target="_blank" rel="noopener">官网</a></li>
<li>「oh my zsh」的 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">GitHub地址</a></li>
<li>「oh my zsh」的 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki" target="_blank" rel="noopener">wiki</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/10/Singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵昌吾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="这是一个程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/10/Singleton/" itemprop="url">
                  Singleton of iOS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-07-10 16:27:13" itemprop="dateCreated datePublished" datetime="2016-07-10T16:27:13+08:00">2016-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-31 10:46:41" itemprop="dateModified" datetime="2018-07-31T10:46:41+08:00">2018-07-31</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单例模式-－-Singleton"><a href="#单例模式-－-Singleton" class="headerlink" title="单例模式 － Singleton"></a>单例模式 － Singleton</h1><p>单例模式确保每个指定的类只存在一个实例对象，并且可以全局访问那个实例</p>
<h2 id="产生的背景／解决的问题"><a href="#产生的背景／解决的问题" class="headerlink" title="产生的背景／解决的问题"></a>产生的背景／解决的问题</h2><ul>
<li>某个类经常被使用，避免其被频繁的创建销毁</li>
<li>共享数据，如NSUserDefault进行本地化<br><img src="/images/Singleton/Singleton_1.png" alt="单例使用原理"></li>
</ul>
<h2 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h2><p><img src="/images/Singleton/Singleton_2.png" alt="单例的结构"></p>
<blockquote>
<p>这是一个日志类，有一个属性 (是一个单例对象) 和两个方法 (sharedInstance() 和 init())。第一次调用 sharedInstance() 的时候，instance 属性还没有初始化。所以我们要创建一个新实例并且返回。下一次你再调用 sharedInstance() 的时候，instance 已经初始化完成，直接返回即可。这个逻辑确保了这个类只存在一个实例对象。</p>
</blockquote>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><strong>下面是<a href="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW32" target="_blank" rel="noopener">Apple官方文档里面关于单例(Singleton)的示范代码</a>，MRC。</strong>线程安全的问题，这里先不说。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MyGizmoClass *sharedGizmoManager = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">+ (MyGizmoClass*)sharedManager &#123;</span><br><span class="line">  <span class="keyword">if</span> (sharedGizmoManager == <span class="literal">nil</span>) &#123;</span><br><span class="line">  sharedGizmoManager = [[<span class="keyword">super</span> allocWithZone:<span class="literal">NULL</span>] init];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sharedGizmoManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">  <span class="keyword">return</span> [[<span class="keyword">self</span> sharedManager] <span class="keyword">retain</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSUIntegerMax</span>;  <span class="comment">//denotes an object that cannot be released</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)release &#123;</span><br><span class="line">  <span class="comment">//do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)autorelease &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>为单例对象创建一个静态实例，可以写成全局的，也可以在类方法里面实现，并初始化为<code>nil</code>；</li>
<li>实现一个实例构造方法，检查上面声明的静态实例是否为<code>nil</code>，如果是，则创建并返回一个本类的实例；</li>
<li>重写<code>allocWithZone方法</code>，用来保证其他人直接使用<code>alloc</code>和<code>init</code>试图获得一个新实力的时候不产生一个新实例；</li>
<li>适当实现<code>copyWithZone</code>，<code>mutableCopyWithZone</code>，非arc下还需要实现<code>release</code>和<code>autorelease</code>方法。</li>
</ol>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><h4 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h4><blockquote>
<p> 从面向对象的角度触发，当需要一个数据对象为<strong>整类而非某个对象服务</strong>，同时有力求不破坏类的封装性，既要求此成员隐藏在类的内部，又要求对外不可见的时候，就可以使用static。</p>
</blockquote>
<ul>
<li>这个变量在编译期会对这个变量进行初始化赋值，也就是说这个变量值要么为nil，要么在编译期就可以确定其值，一般情况下，只能用NSString或者基本类型;</li>
<li><code>static</code>变量存储在静态内存中，不属于堆和栈，程序只会分配一次内存，会在程序退出的时候释放。</li>
</ul>
<h4 id="Alloc-amp-amp-AllocWithZone"><a href="#Alloc-amp-amp-AllocWithZone" class="headerlink" title="Alloc &amp;&amp; AllocWithZone"></a>Alloc &amp;&amp; AllocWithZone</h4><ul>
<li>这两个方法是控制内存分配的；</li>
<li>在<code>NSObject</code>这个类的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html" target="_blank" rel="noopener">官方文档</a>里面，<code>allocWithZone</code>方法介绍说，该方法的参数是被忽略的，正确的做法是传nil或者NULL参数给它。而这个方法之所以存在，是历史遗留原因;</li>
<li><code>[[self alloc] init]</code>调用时，会默认调用<code>+(id)allocWithZone:(NSZone *)zone</code>(这里不讨论什么是<code>NSZone</code>)，为了保持单例类实例的唯一性，需要覆盖所有会生成新的实例的方法，如果有人初始化这个单例类的时候不走<code>[[Class alloc] init]</code>，而是直接<code>allocWithZone</code>，那么这个单例就不再是单例了，所以必须把这个方法也堵上；</li>
</ul>
<h4 id="copyWithZone-amp-amp-mutableCopyWithZone"><a href="#copyWithZone-amp-amp-mutableCopyWithZone" class="headerlink" title="copyWithZone &amp;&amp; mutableCopyWithZone"></a>copyWithZone &amp;&amp; mutableCopyWithZone</h4><ul>
<li>为了避免在<code>copy</code>的时候创建一个新的对象，我们需要重写<code>copyWithZone</code>;</li>
</ul>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p><img src="/images/Singleton/Singleton_3.png" alt="线程安全示意图"></p>
<ul>
<li>为了避免出现上图所示的问题，这里我们可以在init的时候加上线程锁；</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">  <span class="keyword">static</span> MySingleton *_singleton = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_singleton) &#123;</span><br><span class="line">      _singleton = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最终实现代码-ARC"><a href="#最终实现代码-ARC" class="headerlink" title="最终实现代码(ARC)"></a>最终实现代码(ARC)</h3><h4 id="依据上面的说明我们来实现一个单例"><a href="#依据上面的说明我们来实现一个单例" class="headerlink" title="依据上面的说明我们来实现一个单例"></a>依据上面的说明我们来实现一个单例</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">  <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">      _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> sharedInstance];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">  <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="我们还可以通过GCD来实现单例"><a href="#我们还可以通过GCD来实现单例" class="headerlink" title="我们还可以通过GCD来实现单例"></a>我们还可以通过GCD来实现单例</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> GCDSingleton *_instance = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">  _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">  <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="这里我们介绍一种创建单例的宏-看起来用的很爽，反正我不推荐"><a href="#这里我们介绍一种创建单例的宏-看起来用的很爽，反正我不推荐" class="headerlink" title="这里我们介绍一种创建单例的宏(看起来用的很爽，反正我不推荐)"></a>这里我们介绍一种创建单例的宏(看起来用的很爽，反正我不推荐)</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h文件</span></span><br><span class="line"><span class="meta">#define CHSingletonH(name) + (instancetype)shared##name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m文件</span></span><br><span class="line"><span class="meta">#define CHSingletonM(name) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance; \</span><br><span class="line">\</span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">  _instance = [<span class="keyword">super</span> allocWithZone:zone]; \</span><br><span class="line">  &#125;); \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">  &#125; \</span><br><span class="line">\</span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared<span class="meta">##name \</span></span><br><span class="line">&#123; \</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">    _instance = [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">\</span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">  <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>====================用法=====================</em></strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MacroSingleton</span> : <span class="title">NSObject</span></span></span><br><span class="line">CHSingletonH(MacroSingleton)</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MacroSingleton</span></span></span><br><span class="line">CHSingletonM(MacroSingleton)</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：用的时候后面没有<code>&quot;;&quot;</code></p>
<h4 id="偷懒的方法有很多种，比如下面"><a href="#偷懒的方法有很多种，比如下面" class="headerlink" title="偷懒的方法有很多种，比如下面"></a>偷懒的方法有很多种，比如下面</h4><p>Xcode4 引入了一个新<code>feature</code>: <code>code snippets</code>，具体用法自行查找。下面提供两篇博客的链接</p>
<ul>
<li><a href="http://blog.devtang.com/2012/02/04/use-git-to-manage-code-snippets/" target="_blank" rel="noopener">使用 Git 来管理 Xcode 中的代码片段</a></li>
<li><a href="http://nshipster.cn/xcode-snippets/" target="_blank" rel="noopener">Xcode Snippets</a></li>
</ul>
<h3 id="Swift实现单例的进化之路"><a href="#Swift实现单例的进化之路" class="headerlink" title="Swift实现单例的进化之路"></a>Swift实现单例的进化之路</h3><h4 id="先仿照OC的实现方式进行，相传这是最丑的方法"><a href="#先仿照OC的实现方式进行，相传这是最丑的方法" class="headerlink" title="先仿照OC的实现方式进行，相传这是最丑的方法"></a>先仿照OC的实现方式进行，相传这是最丑的方法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftSingleton</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">sharedInstance</span>: <span class="title">SwiftSingleton</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Static</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> onceToken: dispatch_once_t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> instance: <span class="type">SwiftSingleton</span>? = <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  dispatch_once(&amp;<span class="type">Static</span>.onceToken) &#123;</span><br><span class="line">    <span class="type">Static</span>.instance = <span class="type">SwiftSingleton</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Static</span>.instance!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 Swift 1.2 之前并不支持存储类型的类属性，所以我们需要使用一个 struct 来存储类型变量。</p>
</blockquote>
<h4 id="Swift-里用-let-保证线程安全"><a href="#Swift-里用-let-保证线程安全" class="headerlink" title="Swift 里用 let 保证线程安全"></a>Swift 里用 <code>let</code> 保证线程安全</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftSingleton</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">sharedManager</span> : <span class="title">SwiftSingleton</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Static</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance : <span class="type">SwiftSingleton</span> = <span class="type">MyManager</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Static</span>.sharedInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Swift-1-2-之前的最佳实践"><a href="#Swift-1-2-之前的最佳实践" class="headerlink" title="Swift 1.2 之前的最佳实践"></a>Swift 1.2 之前的最佳实践</h4><p>由于 Swift 1.2 之前 class 不支持存储式的 property，我们想要使用一个只存在一份的属性时，就只能将其定义在全局的 scope 中。值得庆幸的是，在 Swift 中是有访问级别的控制的，我们可以在变量定义前面加上 private 关键字，使这个变量只在当前文件中可以被访问。这样我们就可以写出一个没有嵌套的，语法上也更简单好看的单例了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> sharedInstance = <span class="type">MyManager</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyManager</span>  </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">sharedManager</span> : <span class="title">MyManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sharedInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Swift-1-2-之后的推荐用法"><a href="#Swift-1-2-之后的推荐用法" class="headerlink" title="Swift 1.2 之后的推荐用法"></a>Swift 1.2 之后的推荐用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SwiftSingleton  &#123;</span><br><span class="line">  static let sharedInstance = SwiftSingleton()</span><br><span class="line">  private init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化类变量的时候，Apple 将会把这个初始化包装在一次 swift_once_block_invoke 中，以保证它的唯一性。另外，我们在这个类型中加入了一个私有的初始化方法，来覆盖默认的公开初始化方法，这让项目中的其他地方不能够通过 init 来生成自己的 MyManager 实例，也保证了类型单例的唯一性</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>提供了对唯一实例的受控访问。</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</li>
<li>因为单例模式的类控制了实例化的过程，所以类可以更加灵活修改实例化过程。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。</li>
</ul>
<h2 id="注意事项；"><a href="#注意事项；" class="headerlink" title="注意事项；"></a>注意事项；</h2><ul>
<li>不要继承单例类</li>
<li>先创建子类永远是子类对象</li>
<li>先创建父类永远是父类对象</li>
</ul>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul>
<li>应用本身就是一个单例<code>[UIApplication sharedApplication]</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIWindow *window = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">UINavigationController * navigation = (UINavigationController *)window.rootViewController;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们常用<code>NSUserDefaults</code>本地化一些数据</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">[userDefaults setObject:obj forKey:key];</span><br><span class="line">[userDefaults objectForKey:key];</span><br></pre></td></tr></table></figure>
<ul>
<li>网络请求在我们的应用开发中我觉得是最常用的需要代码复用的部分，因为他使用次数多，且代码都差不多，不受别的模块代码干扰，即低耦合,高内聚。我们进行网络请求要先创建一个<code>manager</code>，就是说每次请求我们都需要创建<code>manager</code>，但是频繁的创建销毁很浪费系统资源，完全没有必要，因此我们就可以将<code>manager</code>封装成一个单例。在<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworkingDemo</a>中就是将<code>AFHTTPSessionManager</code>封装成一个单例。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedClient &#123;</span><br><span class="line">  <span class="keyword">static</span> AFAppDotNetAPIClient *_sharedClient = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">  _sharedClient = [[AFAppDotNetAPIClient alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:AFAppDotNetAPIBaseURLString]];</span><br><span class="line">  _sharedClient.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _sharedClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[NSNotificationCenter defaultCenter]</code></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">赵昌吾</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赵昌吾</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
